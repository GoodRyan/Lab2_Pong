Lab2_Pong
=========

Introduction
============

The purpose of this lab was first to display "AF" on the screen using the drivers we created in Lab 1. The next goal was to create a "paddle" that could be moved up and down using two push buttons on the FPGA. Lastly, a moving ball was created that would correctly bounce off of the top, right, and bottom walls as well as the paddle. If it came in contact with the left wall, it was to stop. This would signify the end of the game. After this occurred the player could press the reset button to initiate another game.

Implementation
==============

This lab used the code written in lab 1 to drive the monitor. If you have any questions on how the monitor was driven, refer to the ECE383_Lab1 readme.

The first thing that was created in this lab was a stationary, blue AF printed on the black monitor screen. This was accomplished by writing out code for each block of the A and the F. For example, a block of code creating the left vertical piece of the A was seperate from the block of code creating the right vertical piece. I later combined these pieces where I was able to. After this was complete the ball drawing was placed first in the procedure, so that the letter drawings would take precedence over it. The paddle drawing was placed at the end, as there was no need to ever overwrite it.

The next portion of the project was the player controlled paddle. The first step to getting the paddle to work was to allow the program to recognize the top and bottom button inputs via some changes to the UCF file. Next, a pong_control entity was created. After working on this entity for a while, it became apparent through speaking with Captain Branchflower that the project would be much easier if I also created seperate entities for handling button presses. The button pressed entity took in either an up or down signal from the corresponding button, debounced that signal, and then produced a high output after this was accomplished. I instantiated two of these components, one for the up button and one for the down button, to aid in the movement of the paddle generated by the pong control entity. The pong control entity used the outputs of the two button pressed components to check what button had been pressed. If the up button was pressed, the paddle was moved -5 pixels. If the down button was pressed, th paddle was moved +5 pixels. This was also limited by a check to see if the paddle was about to exceed the limits of the screen.

The final portion of the project was the ball logic. The ball logic was placed inside of the pong control entity, and used a state machine to define its motion. The states included movement, right wall, left wall, bottom wall, paddle bounce upper, and paddle bounce lower. The right wall state would change the ball's x movement speed so that it would move to the left, the bottom wall would change the y movement speed along with the top wall. The left wall stopped the ball in order to end the game. The paddle bounce upper state would bounce the ball to the right and upwards if it contacted the upper half of the paddle. The paddle bounce lower state would bounce the ball to the right and downwards if it contacted the lower half of the paddle.

Below is a drawing of the state machine used in the button pressed entity.

![alt tag](button_pressed_state_machine.PNG)


Test/Debug
==========

* The first portion of this lab that required testing and debugging was the paddle.
  * After writing my paddle code in the pong control entity, I quickly realized the that paddle was not behaving at all as it should. The lead me to create a seperate entity to handle button presses, allowing me to better understand the problem.
  * When this was complete, the paddle was behaving much the same as it had before. I wrote a test bench to try and track down the problem, but found that the paddle responded to button presses exactly as it should. This lead me to believe that the problem was related to debouncing.
  * After adding in debouncing functionality, i found the problem had made itself worse as the paddle was virtually non-responsive.
  * Looking over my code again, I realized that I had forgot to include the counter that allows for debouncing in the process sensitivities for my next-state logic. I had created an inferred latch!
  * After fixing my sensitivity list, and adjusting other sensitivity lists due to realizing I had created other inferred latches, the paddle worked as it should.

* The next portion of the lab that needed to be tested and debugged was the ball movement.
  * Once again, in this portion of the lab I made an inferred latch error. I forgot to include the ball_x location register in the sensitivity list for my next state logic. 
  * After I fixed this issue and got the right wall bounce working, the other wall bounces were fairly simple to implement. Little debugging was necessary for this portion of the lab.

Conclusion
==========

  This lab taught me a great deal about abstraction, and using it to simplify a problem. Without using abstraction, the problem of moving the paddle was much more complex. After implementing a design that used the abstraction to simplify the issue, the code became much easier to write. I also learned more about how the UCF file works, and how inputs can be named anything I desire them to be. This lab also reinforced the importance of avoiding inferred latches, and debouncing inputs. The only thing I would recommend adding to the lab, is a hint that the student use a seperate entity to handle button presses.
